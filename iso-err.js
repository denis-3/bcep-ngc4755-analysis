// uncertainty in isochrone for extinction and distance (modulus)
// find std. dev from isochrone in x and y direction, respectively
// also find rms of the metallicities

const fs = require("fs")
const { plot } = require("nodeplotlib")

const ISOCHRONE_FILE = "./cluster-data/our-isochrone.csv"
const METALS_FILE = "./cluster-data/cluster-metals.tsv"

// array of [x,y]
const starPoints = []
const controlPoints = []

fs.readFileSync(ISOCHRONE_FILE, "utf8")
	.split("\n")
	.map(l => l.split(",").map(v => Number(v)).filter(v => v !== 0))
	.slice(1)
	.forEach(l => {
	starPoints.push([l[0], l[1]])
	if (l.length == 4) {
		controlPoints.push([l[2], l[3]])
	}
})


// [value, included points count]
var extinctionRmsd = [0, 0]
var distModRmsd = [0, 0]

starPoints.forEach(sp => {
	const rx = findResidualFromControls(sp, controlPoints, "x")
	if (rx !== undefined) {
		extinctionRmsd[0] += rx ** 2
		extinctionRmsd[1] ++
	}
	const ry = findResidualFromControls(sp, controlPoints, "y")
	if (ry !== undefined) {
		distModRmsd[0] += ry ** 2
		distModRmsd[1] ++
	}
})

console.log("e points", extinctionRmsd[1])
console.log("dm points", distModRmsd[1])
console.log("total points", starPoints.length)

extinctionRmsd = Math.sqrt(extinctionRmsd[0] / extinctionRmsd[1])
distModRmsd = Math.sqrt(distModRmsd[0] / distModRmsd[1])

var metalsData = fs.readFileSync("./cluster-data/cluster-metals.tsv", "utf8").split("\n")
metalsData = metalsData.slice(metalsData.findIndex(e => e.startsWith("-"))+1).filter(e => e.includes(";")).map(e => e.split(";").map(v => Number(v)))

const metalRms = Math.sqrt(metalsData.reduce((a, c) => a + c[4] ** 2, 0) / metalsData.length)

console.log("E(B-V) uncertainty", extinctionRmsd)
console.log("Distance modulus uncertainty", distModRmsd)
console.log("Metals uncertainty", metalRms)

process.exit(1)

// testing things

const testPoint = starPoints[177]

console.log(controlPoints)

console.log(testPoint)
console.log("x reference", findResidualFromControls(testPoint, controlPoints, "x"))
console.log("y reference", findResidualFromControls(testPoint, controlPoints, "y"))

const isoTrace = {
	x: controlPoints.map(c => c[0]),
	y: controlPoints.map(c => c[1]),
	mode: "markers+lines",
	marker: {
		color: "green",
		size: 6
	},
	line: {
		color: "lightgreen",
		width: 2
	}
}

const pointTrace = {
	x: [0, testPoint[0], 4.7],
	y: [testPoint[1], testPoint[1], testPoint[1]],
	mode: "markers+lines",
	marker: {
		color: "red",
		size: 6
	},
	line: {
		color: "orange",
		width: 2
	}
}

const pointTrace2 = {
	x: [testPoint[0], testPoint[0]],
	y: [25, 5],
	mode: "markers+lines",
	marker: {
		color: "red",
		size: 6
	},
	line: {
		color: "orange",
		width: 2
	}
}

const layout = {
	height: 500,
	width: 700,
	margin: {
		t: 50,
		l: 50,
		b: 50,
		r: 50
	}
}

plot({
	data: [isoTrace, pointTrace2, pointTrace],
	layout
})

// function

// find the residual from the line generated by the control points, in the "direction" direction (x or y)
function findResidualFromControls(inPoint, controlPoints, direction) {
	const xOrY = direction == "x" ? 1 : 0 // when x you need to find matching y values and vice versa
	var bestResid = -1
	for (var i = 0; i < controlPoints.length-1; i++) {
		const p = controlPoints[i]
		const suitableClamps = (p[xOrY] <= inPoint[xOrY] && inPoint[xOrY] <= controlPoints[i+1][xOrY]) ||
			(p[xOrY] >= inPoint[xOrY] && inPoint[xOrY] >= controlPoints[i+1][xOrY])

		if (suitableClamps) {
			const slope = (controlPoints[i+1][1] - controlPoints[i][1]) / (controlPoints[i+1][0] - controlPoints[i][0])

			var refVal = -1
			if (direction == "x") {
				refVal = (inPoint[1] - controlPoints[i][1]) / slope + controlPoints[i][0]
			} else {
				refVal = slope * (inPoint[0] - controlPoints[i][0]) + controlPoints[i][1]
			}

			const thisResid = inPoint[1 - xOrY] - refVal
			if (thisResid < bestResid || bestResid == -1) {
				bestResid = thisResid
			}
		}
	}

	if (bestResid === -1) return undefined
	return bestResid
}
